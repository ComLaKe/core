\documentclass[a4paper,oneside,12pt]{book}
\usepackage[vietnamese,english]{babel}
\usepackage{lmodern}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{titling}
\usepackage{ccicons}
\usepackage[Bjornstrup]{fncychap}
\usepackage{hyperref}
\usepackage[titletoc]{appendix}
\usepackage[numbib]{tocbibind}
\usepackage[acronym,numberedsection=autolabel,section,toc]{glossaries}

\author{\selectlanguage{vietnamese}Nguyễn Gia Phong}
\title{Development of Data Lake Core}
\newcommand{\doi}[1]{\href{https://doi.org/#1}{doi:#1}}

\makeglossaries
\newglossaryentry{content}{name=content,description={a file or a directory}}
\newglossaryentry{predicate}{name=predicate,description={an expression
evaluating to either true or false}}

\newacronym{usth}{USTH}{University of Science and Technology of Hanoi}
\newacronym{api}{API}{application programming interface}
\newacronym{id}{ID}{identifier}
\newacronym{cid}{CID}{\gls{content} \gls{id}}
\newacronym{db}{DB}{database}
\newacronym{fs}{FS}{file system}
\newacronym{io}{I/O}{input/output}

\begin{document}
\frontmatter

% Template: https://www.latextemplates.com/template/academic-title-page
\pagestyle{empty}
\begin{center}\large
  \textsc{\Large\selectlanguage{vietnamese}\begin{tabular}{c}
    University of Science\\
    and Technology of Hanoi
  \end{tabular}}
  \vfill\vfill
  \textsc{Bachelor Thesis}
  \vfill
  \textbf{\LARGE\begin{tabular}{c}
    \toprule
    \thetitle\\
    \bottomrule
  \end{tabular}}
  \vfill
  \begin{minipage}[t]{0.4\textwidth}
    \begin{flushleft}
      \textit{Author}\\
      \theauthor
    \end{flushleft}
  \end{minipage}
  \hspace{0.12\textwidth}
  \begin{minipage}[t]{0.4\textwidth}
    \begin{flushright}
      \textit{Supervisor}\\
      \selectlanguage{vietnamese}
      Trần Giang Sơn, PhD
    \end{flushright}
  \end{minipage}
  \vfill\vfill\vfill
  \today
  \vfill
  \includegraphics[width=0.3\textwidth]{usth-logo.pdf}
  \vfill
\end{center}
\clearpage

\begin{center}
  \copyright{} 2021 \theauthor

  \vspace{1.5em}
  \thetitle

  \vspace{1.5em}
  \ccbysa

  \vspace{0.5em}
  This work is licensed under
  a \href{https://creativecommons.org/licenses/by-sa/4.0}{Creative Commons\\
  Attribution-ShareAlike 4.0 International License}.

  \vspace{1.5em}
  \doi{10.5281/zenodo.5091222}
\end{center}
\clearpage

\setcounter{page}{1}
\pagestyle{plain}
\tableofcontents

\chapter{Declaration}
I declare that I have composed this thesis in its entirety, as the result
of my own work, unless explicitly indicated otherwise via referencing.
The presented work has not been submitted for any previous application
for a degree or professional qualification.

%\chapter{Preface}
%\chapter{Abstract}

\mainmatter
\pagestyle{headings}
\chapter{Introduction}
\section{Motivation}
Many researchers at \gls{usth} operate with data on a regular basis
and often a dataset is studied by multiple researchers from different
departments and points in time.  Currently the data are organized manually,
even on the laboratories' storages, which is prone to duplication
and makes data discovery difficult.

A data lake shared among the university's researchers, professors and students
will not only save resources but also improve productivity and promote
interdisciplinary collaborations.  With \gls{usth}'s goal of growing to be
an excellent research university in {\selectlanguage{vietnamese}Việt Nam}
and in the region~\cite{usth}, building such data lake can be an essential task.

\section{Background}
A \emph{data lake} is a massive repository of multiple types of data
in their raw format at scale for a low cost~\cite{lake}.
The data's schema (structure) is defined on read to minimize data modeling
and integration costs~\cite{lake}.

For the ease and efficiency of scaling, a microservice architecture
could be a good choice.  By arranging the data lake as a collection
of loosely-coupled services, it becomes possible to scale individual services
individually~\cite{micro}.  In this architecture, the \emph{core} microservice
is defined as the innermost component, which communicates directly
with the storages.  The core shall provide an \gls{api} for other components
to upload, query and extract data.

\emph{Append-only storages} only allow new data to be appended, whilst ensure
the immutability of existing data.  As immutable data are thread-safe,
they reduce the complexity of the concurrency model, making it easier
to comprehend and reason about~\cite{pure}.  This is particularly useful
in large distributed systems with multiple moving parts.

Since the data are immutable, each \emph{\gls{content}} can be given
an \gls{id}, i.e.~a \gls{cid}.  For end-users, we also introduce
a higher level concept: \emph{dataset}, composing of not only the content
but also relevant metadata for indexing.  Like contents, datasets can also
immutable, with changes written as a new revision linking to the previous one.

Append-only storages' operations boil down to two kinds: appending and reading.
For the latter, sometimes the data are not wanted in their entirety,
but filtered and accumulated.  While data of different types usually requires
different tools and libraries to query upon, the core \gls{api} should be
providing one single query language for all data types, plus their metadata.
In this thesis, such usage is referred to as \emph{query polymorphism}.

\section{Objectives}
The work presented here was done as part of a three-month internship
in collaboration with several other students
at \gls{usth} ICTLab\footnote{\url{https://ictlab.usth.edu.vn}} to build
a data lake for a better management of the university's data.  The internship
focused on the lake's core microservice, which abstracts underlying
persistent layers and perform relevant metadata transformation and discovery.
It should provide an internal interface to other components for data ingestion,
(primitive) query and extraction, as well as carrying out tasks for enhancing
the discoverability and usability of the aforementioned datasets.

After the internship period, the resulting codebase shall be maintained
by ICTLab and future students, so the work must be designed, implemented
and documented in a way that ensures such possibility.

\section{Expected Outcomes}
The intended deliverables of the three-month internship are listed as follows:
\begin{itemize}
  \item Requirement analysis of the data lake core
  \item Data lake core's architecture and design
  \item Core \gls{api} design and specification
  \item Implementation and integration with other components
\end{itemize}

\chapter{Methodology}
\section{Requirement Analysis}
In this section, from given context and objectives, we analyzed
the expected system for a set of features and derived a list of use cases.
Supplementary specifications were also added to elaborate
on the nonfuntional requirements.

\subsection{Use-Case Model}
As previously introduced, the most basic functions of the data lake core
are content uploading and downloading, along with datasets addition
and querying.  A more advanced (and rather powerful) use case is
content extraction, which allows one to fetch only the interested part
of the content, e.g.~extracting rows matching a certain \gls{predicate}
from (semi-)structured data.  Together with logging, the core's use cases
are summarized in figure \ref{uc}.

\begin{figure}
  \includegraphics[width=\textwidth]{diagrams/uc.eps}
  \caption{Use-case diagram}
  \label{uc}
\end{figure}

\subsubsection{Upload content}
This use case allows other microservices of the data lake to upload
a \gls{content}.  Its flow of events is depicted as follows,
where error handling is omitted for brevity, since all errors, if occur,
replace the normal response.
\begin{enumerate}
  \item A \gls{content} is sent to the core microservice.
  \item Core adds the content to the underlying storage
    and register it to the \gls{db}.
  \item Core responds with the \gls{cid} of the added \gls{content}.
\end{enumerate}

\subsubsection{Add dataset}
This use case allows other microservices to add a dataset:
\begin{enumerate}
  \item A dataset is sent to the core microservice.
  \item Core adds the dataset to the underlying \gls{db}.
  \item Core responds with the \gls{id} of the added dataset.
\end{enumerate}

\subsubsection{Find datasets}
This use case allows other services to find the datasets
whose metadata satisfy a given \gls{predicate}:
\begin{enumerate}
  \item A \gls{predicate} is sent to the core microservice.
  \item Core runs a query in the underlying \gls{db} to find matching datasets.
  \item Core responds with a linear collection of metadata,
    each of which satisfying the given \gls{predicate}.
\end{enumerate}

\subsubsection{Download content}
This use case allows other services to download a \gls{content}:
\begin{enumerate}
  \item A \gls{cid} is sent to the core microservice.
  \item Core passes the \gls{cid} to the underlying storage.
  \item Core responds with the respective \gls{content}.
\end{enumerate}

\subsubsection{Extract content}
This use case allows other services to extract a content's parts
satisfying a given \gls{predicate}:
\begin{enumerate}
  \item A CID and a \gls{predicate} is sent to the core microservice.
  \item Core iterates the content for matching elements.
  \item Core responds with the extracted elements.
\end{enumerate}

\subsubsection{Gather logs}
This use case allows system admins to study events occurring
in the core microservice for debugging purposes:
\begin{enumerate}
  \item A system admin requests logs from core.
  \item The admin receives the list of past events.
\end{enumerate}

\subsection{Supplementary Specification}

\section{Design}
\subsection{Architecture}
\begin{figure}
  \includegraphics[width=\textwidth]{diagrams/arch.eps}
\end{figure}

\subsection{Technology Choices}

\subsection{Interface}
\begin{figure}
  \includegraphics[width=\textwidth]{diagrams/api.eps}
  \caption{Core HTTP API endpoints in a common order of access}
  \label{db}
\end{figure}

\subsection{Database Schema}
\begin{figure}
  \includegraphics[width=\textwidth]{diagrams/db.eps}
  \caption{Database schema}
  \label{db}
\end{figure}

\subsection{Query Abstract Syntax Tree}

\section{Implementation}
\subsection{Error Handling}
\subsection{I/O Handling}
\subsection{Query Transformations}
\subsection{Concurrency}
\subsection{Logging}

\section{Quality Assurance}

\chapter{Results and Discussion}
\section{Results}
\section{Discussion}

\chapter{Conclusion}

\begin{appendices}
\chapter{Acknowledgment}
This work would not have been possible without open access,
Sci-Hub and Library Genesis.  In addition, Wikipedia was a great index
and summary for books and articles of certain topics.

Moreover, I would like to thank my colleagues and supervisors
for their feedbacks, collaborations and encouragements.  My family and friends
(both online and in-real-life) were also incredibly supportive.

\begin{thebibliography}{69}
  \bibitem{usth} \emph{Mission and Vision}.  \acrlong{usth}.
    \url{https://usth.edu.vn/en/abouts/Mission-et-Vision.html}.
  \bibitem{lake} Huang Fang.
    ``Managing Data Lakes in Big Data Era: What's a data lake
    and why has it became popular in data management ecosystem''.
    \emph{2015 IEEE International Conference on Cyber Technology
    in Automation, Control, and Intelligent Systems}, pp.~820--824.
    IEEE, 2015.  \doi{10.1109/CYBER.2015.7288049}
  \bibitem{micro} Chris Richardson.
    ``1.4.1 Scale cube and microservices''.  \emph{Microservice Patterns}.
    Manning Publications, 2018.  ISBN 9781617294549.
  \bibitem{pure} Brian Göetz, Tim Peierls, Joshua Bloch,
    Joseph Bowbeer and David Holmes.
    ``3.4. Immutability''.  \emph{Java Concurrency in Practice}.
    Addison Wesley Professional, 2006.  ISBN 9780321349606.
\end{thebibliography}

\chapter{Terms and Acronyms}
\printglossaries
\end{appendices}
\end{document}
